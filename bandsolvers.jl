module Bandsolvers

using LinearAlgebra: eigen, schur, ‚ãÖ, diagm, diagind, eigvals

"A type for storing the Wannier functions."
mutable struct Wanniers
    minlevel::Int # number of the first energy level of ‚Ñé to use for constructing wanniers (this is used in the unperturbed case)
    targetlevels::Vector{Int} # numbers of quasienergy levels to use for constructing wanniers (this is used in the Floquet case)
    mixsubbands::Bool # whether the two subbands have to be mixed or treated separately (this is used in the unperturbed case)
    n_lo::Vector{Int} # number of levels in the lower subband at each phase; in non-periodic case this depends on the edge state branch position 
    E::Matrix{Float64} # `E[j, i]` = mean energy of `j`th wannier at `i`th phase
    pos::Matrix{Float64} # `pos[j, i]` = position eigenvalue of `j`th wannier at `i`th phase
    d::Array{ComplexF64, 3} # `d[:, :, i]` = position eigenvectors at `i`th phase; see methods of `compute_wanniers!` for details
end

"Default-construct an empty `Wanniers` object."
Wanniers() = Wanniers(0, Int[], false, Int[], Float64[;;], Float64[;;], ComplexF64[;;;])

"""
A type representing the unperturbed Hamiltonian
    ‚Ñé = ùëù¬≤/2ùëÄ + ùëî‚Çócos¬≤(2ùë•) + ùëâ‚Çócos¬≤(ùë• + ùúë‚Çì).
"""
mutable struct UnperturbedHamiltonian
    N::Int  # number of lattice cells
    M::Float64
    l::Int
    g‚Çó::Float64
    V‚Çó::Float64
    isperiodic::Bool
    œÜ‚Çì::Vector{Float64}
    maxlevel::Int   # highest level number to consider
    E::Matrix{Float64}      # `E[i, j]` = `i`th eigenvalue at `j`th phase, `i` ‚àà [1, `maxlevel`], `j` ‚àà [1, `length(œÜ‚Çì)`]
    c::Array{ComplexF64, 3} # `c[:, i, j]` = `i`th eigenvector at `j`th phase
    w::Wanniers
end

"""
Construct an `UnperturbedHamiltonian` object. `maxband` is the highest energy band number to consider.
Each band is assumed to consist of 2 subbands containing `2n_cells` levels in total.
"""
function UnperturbedHamiltonian(n_cells::Integer; M::Real, g‚Çó::Real, V‚Çó::Real, maxband::Integer, isperiodic::Bool, œÜ‚Çì::AbstractVector{<:Real},
                                l::Union{Nothing, Integer}=nothing)
    # convert max band number to level number
    if isperiodic
        maxlevel = maxband * 2n_cells
    else
        maxlevel = (maxband-1) √∑ 2 * 4n_cells + (isodd(maxband) ? 2n_cells-1 : 4n_cells)
    end

    E = Matrix{Float64}(undef, maxlevel, length(œÜ‚Çì))
    c = Array{ComplexF64,3}(undef, 2maxlevel+1, maxlevel, length(œÜ‚Çì))

    UnperturbedHamiltonian(Int(n_cells), Float64(M), (l === nothing ? 1 : l), Float64(g‚Çó), Float64(V‚Çó), isperiodic,
                           collect(Float64, œÜ‚Çì), maxlevel, E, c, Wanniers())
end

"Diagonalise the unperturbed Hamiltonian `uh` at each phase."
function diagonalise!(uh::UnperturbedHamiltonian)
    (;N, M, g‚Çó, V‚Çó, maxlevel) = uh
    sortby = M > 0 ? (+) : (-) # eigenvalue sorting; for ùëÄ < 0 we use descending sorting
    if uh.isperiodic
        h = diagm(0 => ComplexF64[(2j/N)^2 / 2M + (g‚Çó + V‚Çó)/2 for j = -maxlevel:maxlevel])
        h[diagind(h, -2N)] .= h[diagind(h, 2N)] .= g‚Çó/4
        for (i, œï) in enumerate(uh.œÜ‚Çì)
            h[diagind(h, -N)] .= V‚Çó/4 * cis(+2œï)
            h[diagind(h, +N)] .= V‚Çó/4 * cis(-2œï)
            f = eigen(h; sortby)
            uh.E[:, i] = f.values[1:maxlevel]
            uh.c[:, :, i] = f.vectors[:, 1:maxlevel]
        end
    else
        X(j‚Ä≤, j) = 16N*j*j‚Ä≤ / (œÄ*((j-j‚Ä≤)^2-(2N)^2)*((j+j‚Ä≤)^2-(2N)^2))
        n_j = 2maxlevel + 1
        h = zeros(n_j, n_j)
        for (i, œï) in enumerate(uh.œÜ‚Çì)
            for j in 1:n_j
                for j‚Ä≤ in j:n_j
                    val = 0.0
                    if isodd(j‚Ä≤ + j)
                        val += V‚Çó/2 * X(j‚Ä≤, j) * sin(2œï)
                    else
                        # check diagonals "\"
                        if j‚Ä≤ == j
                            val += (g‚Çó + V‚Çó)/2 + (j / N)^2 / 2M
                        elseif j‚Ä≤ == j - 2N || j‚Ä≤ == j + 2N
                            val += V‚Çó * cos(2œï) / 4
                        elseif j‚Ä≤ == j - 4N || j‚Ä≤ == j + 4N
                            val += g‚Çó/4
                        end
                        # check anti-diagonals "/"
                        if j‚Ä≤ == -j - 2N || j‚Ä≤ == -j + 2N
                            val += -V‚Çó * cos(2œï) / 4
                        elseif j‚Ä≤ == -j - 4N || j‚Ä≤ == -j + 4N
                            val += -g‚Çó/4
                        end
                    end
                    h[j‚Ä≤, j] = h[j, j‚Ä≤] = val # push the element to the conjugate positions
                end
            end
            f = eigen(h; sortby)
            uh.E[:, i] = f.values[1:maxlevel]
            uh.c[:, :, i] = f.vectors[:, 1:maxlevel]
        end
    end
end

"""
Calculate Wannier vectors for the unperturbed Hamiltonian using the energy eigenstates in the band number `targetband`.
`mixsubbands` indicates whether the two subbands have to be mixed or treated separately.
"""
function compute_wanniers!(uh::UnperturbedHamiltonian; targetband::Integer, mixsubbands::Bool)
    N = uh.N

    minlevel = (targetband-1) * 2N + 1

    if uh.isperiodic
        E = Matrix{Float64}(undef, 2N, length(uh.œÜ‚Çì))
        pos = Matrix{Float64}(undef, 2N, length(uh.œÜ‚Çì))
        
        if mixsubbands
            d = Array{ComplexF64, 3}(undef, 2N, 2N, length(uh.œÜ‚Çì))
            uh.w = Wanniers(minlevel, Int[], mixsubbands, Int[], E, pos, d)

            X = Matrix{ComplexF64}(undef, 2N, 2N) # position operator
            for i in eachindex(uh.œÜ‚Çì)
                for n in 1:2N
                    for n‚Ä≤ in 1:2N
                        X[n‚Ä≤, n] = sum(uh.c[j+1, minlevel+n‚Ä≤-1, i]' * uh.c[j, minlevel+n-1, i] for j = 1:size(uh.c, 1)-1)
                    end
                end
                _, d[:, :, i], pos_complex = schur(X)
                pos_real = @. mod2pi(angle(pos_complex)) / 2 * N # `mod2pi` converts the angle from [-œÄ, œÄ) to [0, 2œÄ)
                sp = sortperm(pos_real)                 # sort the eigenvalues
                pos[:, i] = pos_real[sp]
                @views Base.permutecols!!(d[:, :, i], sp)    # sort the eigenvectors in the same way
                E[:, i] = [abs2.(dÀ£) ‚ãÖ uh.E[range(minlevel, length=2N), i] for dÀ£ in eachcol(d[:, :, i])]
            end
        else
            # `d` fill format: `d[1:N, 1:N, i]` = eigenvectors of the lower subband,
            #                  `d[1:N, N+1:2N, i]` = eigenvectors of the higher subband
            d = Array{ComplexF64, 3}(undef, N, 2N, length(uh.œÜ‚Çì))
            uh.w = Wanniers(minlevel, Int[], mixsubbands, fill(N, length(uh.œÜ‚Çì)), E, pos, d)

            X = Matrix{ComplexF64}(undef, N, N) # position operator
            for i in eachindex(uh.œÜ‚Çì)
                for o in (0, N)
                    window = 1+o:N+o
                    for n in 1:N
                        for n‚Ä≤ in 1:N
                            X[n‚Ä≤, n] = sum(uh.c[j+1, minlevel+o+n‚Ä≤-1, i]' * uh.c[j, minlevel+o+n-1, i] for j = 1:size(uh.c, 1)-1)
                        end
                    end
                    # `eigen` does not guarantee orthogonality of eigenvectors in case of degeneracies for `X` unitary, so use `schur`
                    # (although a degeneracy of coordinates eigenvalues is unlikely here)
                    _, d[:, window, i], pos_complex = schur(X)
                    pos_real = @. mod2pi(angle(pos_complex)) / 2 * N # `mod2pi` converts the angle from [-œÄ, œÄ) to [0, 2œÄ)
                    sp = sortperm(pos_real)                 # sort the eigenvalues
                    pos[window, i] = pos_real[sp]
                    @views Base.permutecols!!(d[:, window, i], sp)    # sort the eigenvectors in the same way
                    E[window, i] = [abs2.(dÀ£) ‚ãÖ uh.E[range(minlevel+o, length=N), i] for dÀ£ in eachcol(d[:, window, i])]
                end
            end
        end
    else
        n_w = isodd(targetband) ? 2N-1 : 2N+1 # total number of wanniers to construct; this is the number of levels in the target band
        E = Matrix{Float64}(undef, n_w, length(uh.œÜ‚Çì))
        pos = Matrix{Float64}(undef, n_w, length(uh.œÜ‚Çì))
        
        n_j = size(uh.c, 1)
        
        if mixsubbands
            d = Array{ComplexF64, 3}(undef, n_w, n_w, length(uh.œÜ‚Çì))
            uh.w = Wanniers(minlevel, Int[], mixsubbands, Vector{Int}(undef, length(uh.œÜ‚Çì)), E, pos, d)

            X = Matrix{ComplexF64}(undef, n_w, n_w) # position operator
            for i in eachindex(uh.œÜ‚Çì)
                for n in 1:n_w
                    for n‚Ä≤ in n:n_w
                        X[n‚Ä≤, n] = X[n, n‚Ä≤] = (n == n‚Ä≤ ? N*œÄ/2 : 0.0) - 8N/œÄ*sum(uh.c[j, minlevel+n-1, i] * sum(uh.c[j‚Ä≤, minlevel+n‚Ä≤-1, i]*j*j‚Ä≤/(j^2-j‚Ä≤^2)^2
                                                                                 for j‚Ä≤ = (iseven(j) ? 1 : 2):2:n_j) for j = 1:n_j)
                    end
                end
                uh.w.pos[:, i], uh.w.d[:, :, i] = eigen(X)
                uh.w.E[:, i] = [dÀ£.^2 ‚ãÖ uh.E[range(minlevel, length=n_w), i] for dÀ£ in eachcol(uh.w.d[:, :, i])]
            end
        else
            # `d` fill format: `d[1:n_lo[i], 1:n_lo[i], i]` = eigenvectors of the lower subband,
            #                  `d[1:n_w-n_lo[i], n_lo[i]+1:n_w, i]` = eigenvectors of the higher subband
            d = Array{ComplexF64, 3}(undef, n_w√∑2+1, n_w, length(uh.œÜ‚Çì))
            uh.w = Wanniers(minlevel, Int[], mixsubbands, Vector{Int}(undef, length(uh.œÜ‚Çì)), E, pos, d)
            
            X = ComplexF64[;;] # position operator
            X_less = zeros(n_w√∑2, n_w√∑2) # position operator for a subband which does not contain the edge state branch
            X_more = zeros(n_w√∑2+1, n_w√∑2+1) # position operator for a subband which contains the edge state branch
            for i in eachindex(uh.œÜ‚Çì)
                up = uh.E[minlevel+n_w√∑2, i] > (uh.E[minlevel+n_w√∑2-1, i] + uh.E[minlevel+n_w√∑2+1, i])/2 # true if the edge state branch is above the mean value
                
                # Lower band
                X = up ? X_less : X_more # bind the position operator to a matrix of the appropriate size
                n_lo = n_w√∑2 + !up # number of levels in the lower subband
                uh.w.n_lo[i] = n_lo
                for n in 1:n_lo
                    for n‚Ä≤ in n:n_lo
                        X[n‚Ä≤, n] = X[n, n‚Ä≤] = (n == n‚Ä≤ ? N*œÄ/2 : 0.0) - 8N/œÄ*sum(uh.c[j, minlevel+n-1, i] * sum(uh.c[j‚Ä≤, minlevel+n‚Ä≤-1, i]*j*j‚Ä≤/(j^2-j‚Ä≤^2)^2
                                                                                 for j‚Ä≤ = (iseven(j) ? 1 : 2):2:n_j) for j = 1:n_j)
                    end
                end
                uh.w.pos[1:n_lo, i], uh.w.d[1:n_lo, 1:n_lo, i] = eigen(X)
                uh.w.E[1:n_lo, i] = [dÀ£.^2 ‚ãÖ uh.E[range(minlevel, length=n_lo), i] for dÀ£ in eachcol(uh.w.d[1:n_lo, 1:n_lo, i])]

                # Higher band
                X = up ? X_more : X_less
                n_hi = n_w - n_lo
                for n in 1:n_hi
                    for n‚Ä≤ in n:n_hi
                        X[n‚Ä≤, n] = X[n, n‚Ä≤] = (n == n‚Ä≤ ? N*œÄ/2 : 0.0) - 8N/œÄ*sum(uh.c[j, minlevel+n_lo+n-1, i] * sum(uh.c[j‚Ä≤, minlevel+n_lo+n‚Ä≤-1, i]*j*j‚Ä≤/(j^2-j‚Ä≤^2)^2
                                                                                 for j‚Ä≤ = (iseven(j) ? 1 : 2):2:n_j) for j = 1:n_j)
                    end
                end
                uh.w.pos[n_lo+1:n_w, i], uh.w.d[1:n_hi, n_lo+1:n_w, i] = eigen(X)
                uh.w.E[n_lo+1:n_w, i] = [dÀ£.^2 ‚ãÖ uh.E[range(minlevel+n_lo, length=n_hi), i] for dÀ£ in eachcol(uh.w.d[1:n_hi, n_lo+1:n_w, i])]
            end
        end
    end
end

"""
Construct energy eigenfunctions at coordinates in `x` for each eigenstate number in `whichstates` at each phase number in `whichphases`.
Return `œà`, where `œà[:, j, i]` = `j`th eigenfunction at `whichphases[i]`th phase.
"""
function make_eigenfunctions(uh::UnperturbedHamiltonian, x::AbstractVector{<:Real}, whichphases::AbstractVector{<:Integer}, whichstates::AbstractVector{<:Integer})
    œà = Array{ComplexF64,3}(undef, length(x), length(whichstates), length(whichphases))
    make_state = uh.isperiodic ? make_exp_state : make_sin_state
    for (i, iœï) in enumerate(whichphases)
        for (j, js) in enumerate(whichstates)
            @views œà[:, j, i] = make_state(x, uh.c[:, js, iœï]; N=uh.N)
        end
    end
    return œà
end

"""
Construct Wannier functions at coordinates in `x` at each phase number in `whichphases`. All Wannier functions contained in `uh` are constructed.
In the process, energy eigenfunctions are also constructed.
Return `œà, w`, where `œà[:, j, i]` = `j`th eigenfunction at `whichphases[i]`th phase, and `w[:, j, i]` = `j`th Wannier function at `i`th phase.
"""
function make_wannierfunctions(uh::UnperturbedHamiltonian, x::AbstractVector{<:Real}, whichphases::AbstractVector{<:Integer})
    n_w = size(uh.w.E, 1)
    w = Array{ComplexF64, 3}(undef, length(x), n_w, length(uh.œÜ‚Çì))
    œà = make_eigenfunctions(uh, x, whichphases, range(uh.w.minlevel, length=n_w))
    if uh.w.mixsubbands
        for (i, iœÜ) in enumerate(whichphases)
            for j in 1:n_w
                w[:, j, i] = sum(uh.w.d[k, j, iœÜ] * œà[:, k, i] for k = 1:n_w)
            end
        end
    else
        for (i, iœÜ) in enumerate(whichphases)
            for j in 1:uh.w.n_lo[i]
                w[:, j, i] = sum(uh.w.d[k, j, iœÜ] * œà[:, k, i] for k = 1:uh.w.n_lo[i])
            end
            for j in uh.w.n_lo[i]+1:n_w
                w[:, j, i] = sum(uh.w.d[k, j, iœÜ] * œà[:, uh.w.n_lo[i]+k, i] for k = 1:n_w-uh.w.n_lo[i])
            end
        end
    end
    return œà, w
end

"Construct the coordinate-space wavefunction ùúì(ùë•) = ‚àë‚±ºùëê‚±ºexp(2iùëóùë•/ùëÅ) / ‚àö(ùëÅœÄ)"
function make_exp_state(x::AbstractVector{<:Real}, c::AbstractVector{<:Number}; N)
    œà = zeros(eltype(c), length(x))
    n_j = (length(c) - 1) √∑ 2
    for j in -n_j:n_j
        @. œà += c[j+n_j+1] * cis(2j/N * x)
    end
    return œà ./ sqrt(N*œÄ)
end

"Construct the coordinate-space wavefunction ùúì(ùë•) = ‚àë‚±ºùëê‚±ºsin(ùëóùë•/ùëÅ) / ‚àö(ùëÅœÄ/2)"
function make_sin_state(x::AbstractVector{<:Real}, c::AbstractVector{<:Number}; N)
    œà = zeros(eltype(c), length(x))
    for (j, c) in enumerate(c)
        @. œà += c * sin(j/N * x)
    end
    return œà ./ sqrt(N*œÄ/2)
end

"""
A type representing the Floquet Hamiltonian
    ‚Ñã = ‚Ñé - i‚àÇ‚Çú + Œª‚Çõsin¬≤(2ùë•)cos(2ùúîùë°) + Œª‚Çócos¬≤(2ùë•)cos(ùúîùë° + ùúë‚Çú),
where ‚Ñé is the unperturbed Hamiltonian represented by [`UnperturbedHamiltonian`](@ref), and ùúë‚Çú = 2ùúë‚Çì.
"""
mutable struct FloquetHamiltonian
    uh::UnperturbedHamiltonian
    s::Int
    Œª‚Çõ::Float64
    Œª‚Çó::Float64
    œâ::Float64
    pumptype::Symbol
    minlevel::Int # lowest level number of ‚Ñé to use when constructing ‚Ñã
    E::Matrix{Float64}      # `E[i, j]` = `i`th eigenvalue (Floquet quasienergy) at `j`th phase, `i = 1:maxlevel`
    b::Array{ComplexF64, 3} # `b[:, i, j]` = `i`th eigenvector at `j`th phase, `i = 1:maxlevel; j = 1:2maxlevel+1`
    ŒΩ::Vector{Int}  # band map ùúà(ùëö)
end

"""
Construct a `FloquetHamiltonian` object. `minband` is the first energy band of `uh` to use when constructing the Floquet Hamiltonian matrix.
Type of pumping is controlled via `pumptype`: `:time` for temporal, `:space` for spatial, or anything else for simultaneous space-time pumping.
In the case of time-only pumping, it is assumed that ùúë‚Çì = 0, and hence that `uh.œÜ‚Çì[1] == 0`.
"""
function FloquetHamiltonian(uh::UnperturbedHamiltonian; s::Integer, Œª‚Çõ::Real, Œª‚Çó::Real, œâ::Real, pumptype::Symbol, minband::Integer)
    N = uh.N

    bs1 = 2N - 1 # "bandsize 1" = number of levels in the lowest band of ‚Ñé

    # convert min band number to level number
    if uh.isperiodic
        minlevel = (minband - 1) * 2N + 1
    else
        minlevel = (minband - 1) √∑ 2 * 4N + (isodd(minband) ? 1 : bs1 + 1)
    end
    
    if uh.isperiodic
        ŒΩ = [ceil(Int, m/2N) for m in 1:uh.maxlevel] 
    else
        # FIll `ŒΩ`: [1 (`bs1` times), 2 (`bs2 = 2N+1` times), 3 (`bs1` times), 4 (`bs2` times), ...]
        ŒΩ = Vector{Int}(undef, uh.maxlevel)
        number = 1
        for i in 0:uh.maxlevel√∑4N-1
            ŒΩ[4N*i+1:4N*i+bs1] .= number
            number += 1
            ŒΩ[4N*i+bs1+1:4N*i+4N] .= number
            number += 1
        end
        ŒΩ[uh.maxlevel - uh.maxlevel%4N + 1:end] .= number
    end
    
    n_levels = uh.maxlevel - minlevel + 1
    E = Matrix{Float64}(undef, n_levels, length(uh.œÜ‚Çì))
    b = Array{ComplexF64,3}(undef, n_levels, n_levels, length(uh.œÜ‚Çì))
    
    FloquetHamiltonian(uh, Int(s), Float64(Œª‚Çõ), Float64(Œª‚Çó), Float64(œâ), pumptype, Int(minlevel), E, b, ŒΩ)
end

"Diagonalise the Floquet Hamiltonian `fh` at each phase."
function diagonalise!(fh::FloquetHamiltonian)
    # make views
    (;N, œÜ‚Çì, E, c) = fh.uh
    n_j = size(c, 1)
    (;s, œâ, Œª‚Çõ, Œª‚Çó, pumptype, ŒΩ) = fh

    n_levels = fh.uh.maxlevel - fh.minlevel + 1 # number of levels of spatial Hamiltonian to use for constructing ‚Ñã

    H = zeros(ComplexF64, n_levels, n_levels) # ‚Ñã matrix

    ‚àëcc(m‚Ä≤, m, i) = if fh.uh.isperiodic
        sum( (                 c[j+2N, m‚Ä≤, i])' * c[j, m, i] for j = 1:2N ) +
        sum( (c[j-2N, m‚Ä≤, i] + c[j+2N, m‚Ä≤, i])' * c[j, m, i] for j = 2N+1:n_j-2N ) + 
        sum( (c[j-2N, m‚Ä≤, i]                 )' * c[j, m, i] for j = n_j-2N+1:n_j )
    else
        sum( (-c[-j+4N, m‚Ä≤, i] + c[j+4N, m‚Ä≤, i]) * c[j, m, i] for j = 1:4N-1 ) +
                               + c[4N+4N, m‚Ä≤, i] * c[4N, m, i] + # iteration `j = 4N`
        sum( (  c[j-4N, m‚Ä≤, i] + c[j+4N, m‚Ä≤, i]) * c[j, m, i] for j = 4N+1:n_j-4N ) + 
        sum( (  c[j-4N, m‚Ä≤, i]                 ) * c[j, m, i] for j = n_j-4N+1:n_j )
    end

    if fh.uh.isperiodic
        for (i, œï) in enumerate(œÜ‚Çì)
            # `m` and `m‚Ä≤` number the levels of ‚Ñé
            # `e` and `e‚Ä≤` number the elements of `H`
            for m in fh.minlevel:fh.uh.maxlevel
                e = m - fh.minlevel + 1

                # for time-only pumping, always take the eigenenergies at the first phase, which is asssumed to correspond to ùúë‚Çì = 0
                p = (pumptype == :time ? 1 : i)
                H[e, e] = E[m, p] - ŒΩ[m]*œâ/s

                # place the elements of the long lattice
                for g in 1:2N
                    m‚Ä≤ = 2N*(s + ŒΩ[m] - 1) + g
                    e‚Ä≤ = m‚Ä≤ - fh.minlevel + 1
                    e‚Ä≤ > n_levels && break
                    if pumptype != :time || i == 1 # if pumping is time-only, this must be calculated only once, at `i` = 1
                        # if pumping is space-time, then also multiply by cis(-ùúë‚Çú). `œï` runs over ùúë‚Çì, and we assume the pumping protocol ùúë‚Çú = 2ùúë‚Çì
                        H[e‚Ä≤, e] = (pumptype == :space ? Œª‚Çó/8 * ‚àëcc(m‚Ä≤, m, i) : Œª‚Çó/8 * ‚àëcc(m‚Ä≤, m, i) * cis(-2œï))
                    elseif pumptype == :time 
                        H[e‚Ä≤, e] *= cis(-2(œÜ‚Çì[i]-œÜ‚Çì[i-1]))
                    end
                    H[e, e‚Ä≤] = H[e‚Ä≤, e]'
                end
                
                # place the elements of the short lattice
                for g in 1:2N
                    m‚Ä≤ = 2N*(2s + ŒΩ[m] - 1) + g
                    e‚Ä≤ = m‚Ä≤ - fh.minlevel + 1
                    e‚Ä≤ > n_levels && break
                    if pumptype != :time || i == 1 # if pumping is time-only, this must be calculated only once, at `i` = 1
                        H[e‚Ä≤, e] = -Œª‚Çõ/8 * ‚àëcc(m‚Ä≤, m, i)
                    end
                    H[e, e‚Ä≤] = H[e‚Ä≤, e]'
                end
            end
            fh.E[:, i], fh.b[:, :, i] = eigen(H, sortby=-)
        end
    else
        for (i, œï) in enumerate(œÜ‚Çì)
            bs1 = 2N - 1
            bs2 = 2N + 1
            pattern = [fill(bs1, bs1); fill(bs2, bs2)]
            G = repeat(pattern, fh.uh.maxlevel√∑4N) # a pattern which e.g. for `N == 2` looks like [3, 3, 3, 5, 5, 5, 5, 3, 3, 3, 5, 5, 5, 5, ...]
            fh.uh.maxlevel % 4N != 0 && append!(G, fill(bs1, bs1))

            # `m` and `m‚Ä≤` number the levels of ‚Ñé
            # `e` and `e‚Ä≤` number the elements of `H`
            for m in fh.minlevel:fh.uh.maxlevel
                e = m - fh.minlevel + 1

                # for time-only pumping, always take the eigenenergies at the first phase, corresponding to ùúë‚Çì = 0
                p = (pumptype == :time ? 1 : i)
                H[e, e] = E[m, p] - fh.ŒΩ[m]*œâ/s

                # place the elements of the long lattice
                for g in 1:G[m]
                    # skip `s` groups of `4N`, then some more groups depending on `m`, then skip `G[fh.minlevel]` cells
                    e‚Ä≤ = 4N*(s√∑2) + 4N*((fh.ŒΩ[m]-1)√∑2) + iseven(ŒΩ[m])*G[fh.minlevel] + g
                    e‚Ä≤ > n_levels && break
                    m‚Ä≤ = e‚Ä≤ + fh.minlevel - 1 
                    if pumptype != :time || i == 1 # if pumping is time-only, this must be calculated only once, at `i` = 1
                        # if pumping is space-time, then also multiply by cis(-ùúë‚Çú). `œï` runs over ùúë‚Çì, and we assume the pumping protocol ùúë‚Çú = 2ùúë‚Çì
                        H[e‚Ä≤, e] = (pumptype == :space ? Œª‚Çó/8 * ‚àëcc(m‚Ä≤, m, i) : Œª‚Çó/8 * ‚àëcc(m‚Ä≤, m, i) * cis(-2œï))
                    elseif pumptype == :time 
                        H[e‚Ä≤, e] *= cis(-2(œÜ‚Çì[i]-œÜ‚Çì[i-1]))
                    end
                    H[e, e‚Ä≤] = H[e‚Ä≤, e]'
                end
                
                # place the elements of the short lattice
                for g in 1:2N
                    e‚Ä≤ = 4N*s + 4N*((fh.ŒΩ[m]-1)√∑2) + iseven(ŒΩ[m])*G[fh.minlevel] + g
                    e‚Ä≤ > n_levels && break
                    m‚Ä≤ = e‚Ä≤ + fh.minlevel - 1 
                    if pumptype != :time || i == 1 # if pumping is time-only, this must be calculated only once, at `i` = 1
                        H[e‚Ä≤, e] = -Œª‚Çõ/8 * ‚àëcc(m‚Ä≤, m, i)
                    end
                    H[e, e‚Ä≤] = H[e‚Ä≤, e]'
                end
            end
            fh.E[:, i], fh.b[:, :, i] = eigen(H, sortby=-)
        end
    end
end

"""
Construct Floquet modes at coordinates in `x` and time moments in `Œ©t` for each state number in `whichstates` at each phase number in `whichphases`.
Return `u`, where `u[ix, it, j, i]` = `j`th wavefunction at `whichphases[i]`th phase at `ix`th coordinate at `it`th time moment.
"""
function make_eigenfunctions(fh::FloquetHamiltonian, x::AbstractVector{<:Real}, Œ©t::AbstractVector{<:Real}, whichphases::AbstractVector{<:Integer},
                             whichstates::AbstractVector{<:Integer})
    u = Array{ComplexF64,4}(undef, length(x), length(Œ©t), length(whichstates), length(whichphases))
    n_levels = size(fh.E, 1) # number of Floquet levels; equivalently, number of levels of ‚Ñé used for constructing ‚Ñã
    # Eigenfunctions of ‚Ñé, which are mixed during construction of `u`. For time-only pumping use only eigenstates at the first phase, corresponding to ùúë‚Çì = 0
    œà = make_eigenfunctions(fh.uh, x, (fh.pumptype == :time ? [1] : whichphases), range(fh.minlevel, length=n_levels))
    for (i, iœÜ) in enumerate(whichphases)
        p = (fh.pumptype == :time ? 1 : i)
        for (j, js) in enumerate(whichstates)
            for (it, t) in enumerate(Œ©t)
                u[:, it, j, i] = sum(cis(-fh.ŒΩ[m]*t) * œà[:, m, p] * fh.b[m, js, iœÜ] for m in 1:n_levels)
            end
        end
    end
    return u
end

"""
Permute Floquet quasienergy levels contained in `fh.E` so that they are stored in the same order as the eigenenergies of ‚Ñé stored in `fh.uh.E`.
Repeat this for every phase (i.e. column of `fh.E`).
To perfrorm the sorting, first calculate `fh.uh.E - fh.ŒΩ[m]`, which is the diagonal of ‚Ñã. If there is no perturbation, then these
are the Floquet quasienergies. Then, sort them in descending order (as if we diagonalised the Hamiltonian) and find the permutation
that would undo this sorting. This permutation is applied to a copy of `fh.E`.
The procedure yields fully correct results only if `fh.E` has been calculated at zero perturbation. The perturbation may additionally change
the order of levels, and there is no simple way of disentangling the order. The permutation is still useful in that case, but the results 
should not be taken too literally.
"""
function order_floquet_levels(fh::FloquetHamiltonian)
    E = similar(fh.E)
    n_levels = size(fh.E, 1) # number of Floquet levels; equivalently, number of levels of ‚Ñé used for constructing ‚Ñã
    for i in eachindex(fh.uh.œÜ‚Çì)
        E_diag = [fh.uh.E[m, i] - fh.ŒΩ[m] * fh.œâ/fh.s for m in 1:n_levels] # Floquet energies at zero perturbation
        invsort = sortperm(sortperm(E_diag, rev=true))  # inverse permutation, such that `sort(E_diag, rev=true)[invsort] == E_diag`
        E[:, i] .= fh.E[invsort, i]
    end
    return E
end

"""
Calculate Wannier vectors for the Floquet Hamiltonian `fh` using the quasienergy levels `targetlevels`.
"""
function compute_wanniers!(fh::FloquetHamiltonian; targetlevels::AbstractVector{<:Real})
    (;N, œÜ‚Çì, c) = fh.uh

    n_w = length(targetlevels)
    E = Matrix{Float64}(undef, n_w, length(œÜ‚Çì))
    pos = Matrix{Float64}(undef, n_w, length(œÜ‚Çì))
    d = Array{ComplexF64, 3}(undef, n_w, n_w, length(œÜ‚Çì))
    fh.uh.w = Wanniers(0, targetlevels, false, Int[], E, pos, d)
    X = Matrix{ComplexF64}(undef, n_w, n_w) # position operator
    
    n_levels = size(fh.E, 1)
    ‚àëcc = Matrix{ComplexF64}(undef, n_levels, n_levels)
    cis‚àëcc = Matrix{ComplexF64}(undef, n_levels, n_levels)
    
    for i in eachindex(œÜ‚Çì)
        # if pumping is time-only, then `‚àëcc` must be calculated only at the first iteration, thereby using `c`'s at ùúë‚Çì = 0
        if fh.pumptype != :time || i == 1
            for m in range(fh.minlevel, length=n_levels)
                for m‚Ä≤ in range(fh.minlevel, length=n_levels)
                    ‚àëcc[m‚Ä≤-fh.minlevel+1, m-fh.minlevel+1] = sum(c[j+1, m‚Ä≤, i]' * c[j, m, i] for j = 1:size(c, 1)-1)
                end
            end
        end

        t = (fh.pumptype == :space ? œÄ/5 : œÄ/5 - i/length(œÜ‚Çì)*œÄ/2) # time moment at which to diagonalise the coordinate operator
        # `cis‚àëcc` must be calculated at every phase: if pumping is temporal, `t` depends on phase;
        # if pumping is spatial, `‚àëcc` depends on phase (because `c`'s do)
        for m in 1:n_levels
            for m‚Ä≤ in 1:n_levels
                cis‚àëcc[m‚Ä≤, m] = ‚àëcc[m‚Ä≤, m] * cis((fh.ŒΩ[m‚Ä≤+fh.minlevel-1] - fh.ŒΩ[m+fh.minlevel-1]) * t)
            end
        end

        for (in, n) in enumerate(targetlevels)
            for (in‚Ä≤, n‚Ä≤) in enumerate(targetlevels)
                X[in‚Ä≤, in] = sum(fh.b[m, n, i] * sum(fh.b[m‚Ä≤, n‚Ä≤, i]' * cis‚àëcc[m‚Ä≤, m] for m‚Ä≤ in 1:n_levels) for m in 1:n_levels)
            end
        end
        _, d[:, :, i], pos_complex = schur(X)
        pos_real = @. mod2pi(angle(pos_complex)) / 2 * N # `mod2pi` converts the angle from [-œÄ, œÄ) to [0, 2œÄ)
        sp = sortperm(pos_real)         # sort the eigenvalues
        pos[:, i] = pos_real[sp]
        @views Base.permutecols!!(d[:, :, i], sp) # sort the eigenvectors in the same way
        E[:, i] = [abs2.(dÀ£) ‚ãÖ fh.E[targetlevels, i] for dÀ£ in eachcol(d[:, :, i])]
    end
end

"""
Construct Wannier functions at coordinates in `x` at each phase number in `whichphases`. All Wannier functions contained in `fh` are constructed.
In the process, energy eigenfunctions are also constructed.
Return `u, w`, where `w[ix, it, j, i]` = `j`th Wannier function at `whichphases[i]`th phase at `ix`th coordinate at `it`th time moment,
and `u` is an array of Floquet modes in the same format.
"""
function make_wannierfunctions(fh::FloquetHamiltonian, x::AbstractVector{<:Real}, Œ©t::AbstractVector{<:Real}, whichphases::AbstractVector{<:Integer})
    n_w = length(fh.uh.w.targetlevels)
    u = make_eigenfunctions(fh, x, Œ©t, whichphases, fh.uh.w.targetlevels)
    w = Array{ComplexF64, 4}(undef, length(x), length(Œ©t), n_w, length(whichphases))
    for (i, iœÜ) in enumerate(whichphases)
        for j in 1:n_w
            w[:, :, j, i] = sum(fh.uh.w.d[k, j, iœÜ] * u[:, :, k, i] for k = 1:n_w)
        end
    end
    return u, w
end

end